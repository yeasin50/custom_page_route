part of custom_page_route;

/// Ripple page transition based [center]
class RippleRoute<T> extends PageRouteBuilder<T> {
  /// The color of the ripple effect is prioritized over [colors]
  /// If [colors] is null, the color of the ripple effect is generated by mixing [backgroundColor] with white and transparent
  /// If [backgroundColor] is null, the color of the ripple effect is white
  RippleRoute({
    required this.center,
    this.popPosition,
    this.duration,
    this.colors,
    this.backgroundColor,
    required Widget page,
    RouteSettings? settings,
  }) : super(
          pageBuilder: (context, animation, _) => page,
          opaque: false,
          settings: settings,
        );

  /// ripple effect color
  final List<Color>? colors;

  /// only work when [colors] is null
  /// generate color mixing with white and transparent
  final Color? backgroundColor;

  /// transfer animation duration
  final Duration? duration;

  /// animation start point
  final FractionalOffset center;

  /// pop page position, default is [center]
  final FractionalOffset? popPosition;

  List<Color> get _defaultColor {
    final color = backgroundColor ?? Colors.white;
    return [
      color,
      color,
      color.withAlpha(0),
      color.withAlpha(0),
    ];
  }

  get _colors => colors ?? _defaultColor;

  @override
  Duration get transitionDuration => duration ?? const Duration(milliseconds: 500);

  @override
  Duration get reverseTransitionDuration => duration ?? const Duration(milliseconds: 500);

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    // assert(colors != null && colors!.length >= 4, "Colors length should be 4");
    bool isPop = animation.status == AnimationStatus.reverse;

    return ShaderMask(
      shaderCallback: (rect) {
        return RadialGradient(
          radius: animation.value * 5,
          colors: _colors,
          stops: const [0.0, 0.55, 0.6, 1.0],
          center: isPop ? popPosition ?? center : center, //can we make this expression shorter?
          // center: isPop && popPosition != null ? popPosition! : center,
        ).createShader(rect);
      },
      child: child,
    );
  }
}
